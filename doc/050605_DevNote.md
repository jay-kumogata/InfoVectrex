## 光速船エミュレータ開発記

### 2005-06-05

はじめに

「光速船」というゲーム機がありました．
いまは存在しないですが，ベクタースキャンという方式で画面を描画するゲーム機でした（航空管制システムとかといっしょですね）．
ちなみに，ベクタースキャン方式に対するのが，ピクセルで画面を構成するラスタースキャン方式です．
「懐かしい」ということで，エミュレータを作ることにしました．
まずは，いつも通り，情報収集からはじめましょう．

技術情報

以下のサイトなどが参考になります．
Vectrex=光速船です．

- [Vectrex Programming](http://www.playvectrex.com/designit/chrissalo/toc.htm)

CPU

CPUは，6809ということで，まず先行して調査することにしました．
図書館に行って，以下の本を借りてきました．

- [1] "マイクロコンピュータの内部構造と機械語　6809 CPUプログラミング入門", 福永邦雄  (1982).

CPUエミュレータのレジスタ，それぞれの命令などを記述していきましょう．

### 2005-06-12

CPUエミュレーション

ロード，ストア命令

今週末も，あまり時間がとれなかったのですが，6809のLD命令辺りを実装しました．
ほとんどがアドレッシングモードの実装で，インデックスモードが結構複雑でしたが，専用の関数を作って，解決しました．
まだ，ストア命令には，未着手ですが，アドレッシングモードが出来てしまえば，簡単かなという感覚です．

その他

実機

あきばに用事があったので，ついでにLAOXコンピュータ館の前のショップ（3F）で，「ファミ魂家郎」（2,604円）を購入しました．
そこには，光速船の実機が置いてあったのですが，騒ぐとみっともないので，さりげなく見て，「もうすぐエミュレーションしてあげるからなぁ」と心で想います（意味不明）．

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-01.gif" width="320px"/>

「MC6809Eデータシート(p.1)」より引用

### 2005-06-16

ロード・ストア命令

今日は平日でしたが時間がとれたので，少しだけ書き進めました．
インデックスモードの一部（ＰＣ相対）を実装して，アドレッシングモードは，完了しました．
ストア命令も，完了しました．
とりあえず，８ビットだけを優先的に進めることにして，算術命令に行きましょう．

算術命令

加算などを実装しました．疲れてきたので，また今度にします．

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-02.gif" width="320px"/>

「MC6809Eデータシート(p.2)」より引用

### 2005-07-13

InfoNES関連のゴタゴタも収拾されてきたみたいので，また光速船の作業を進めることにしました．
InfoNESの不完全さを，そっちのけにして，新しいことを始めるのは，爽快です．
本日は，お休みだったので，2時間ぐらい作業しました．

_(2021-10-16) この時期，InfoNESはほぼ開発終了しており，PSP(PlayStation Portable)へ移植されています．_
_「ゴタゴタ」とは，そのことへの対応を意味しています．_
_この2年後に，iphoneへ移植されて，さらなる「ゴタゴタ」に巻き込まれることになります．_

フラグ処理

フラグ処理としては，Nフラグ，Zフラグについては，配列（テーブル）を用意して，その配列（テーブル）を参照するようにして実装しました．
Hフラグ，Vフラグ，Cフラグについては，命令毎に変更されるように実装しました．

８ビット演算

ロード命令，ストア命令，加算命令，減算命令を実装し，フラグ処理も反映させます．
次回以降は，論理演算命令，比較命令，分岐命令なんかを実装する予定です．

Hフラグの謎

参考資料の「⑧：この命令が実行されたあとのHフラグまたはVフラグの値は意味を持たない」っていう記述は，どうエミュレートすればよいのか，悩みました．
とりあえず，今は，何もしてません（つまり，前の状態と同じまま）．
ただ，現実のCPUでは，なんらかのルールで，Hフラグが変わるので，それをエミュレートしないと，精度が上がらない危険性ありです．

現状，Hフラグについては，例えば，ADDA命令だったら，
	
	加算の場合　	A=A+Mの時　H = A & M & 0x08
	
で，反映させてます．
累算器(A)と被演算数(M)のビット3が両方とも1だったら，加算時には，ビット4にキャリが立つので，Hフラグ（ハーフキャリ）を立てています．
⑧の命令（減算命令）の時にも，意味はないのですが，このロジックを入れておけば，良いような気もします．
とりあえず，そのままにしておきます．

_(2021-10-16) エミュレータを開発していると，仕様書上でも動作が不明なことが時々あります．_
_その場合は，暫定的に実装しておいて，後日問題があった場合には修正していくことで，精度(Accuracy)を改善できます．_

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-03.gif" width="320px"/>

「MC6809Eデータシート(p.3)」より引用

### 2005-07-17

このように，少しずつ6809エミュレータを書いていると，ブロックを積み上げているような楽しさがありますね．
大きなビルを，ひとつひとつブロックを積んでいく作業みたいです．

作業時間

開発開始から，1ヶ月ぐらい経ちましたが，土日に4時間づつぐらい作業しているので，32( = 4 x 4 x 2)時間ぐらいは，費やしたでしょうか．
誰か言ってましたが，エミュレータを書き上げるには，初期リリースまで500時間は必要（完成までは2000時間が必要）らしいので，まだまです．
500時間で初期リリースにいけるかが不安です．

作業内容

前回と比較して，8ビットの論理演算（AND，OR，EOR），インクリメント，ディクリメント命令を実装しました．
次は，比較命令，分岐命令辺りに，着手したいです．

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-04.gif" width="320px"/>

「MC6809Eデータシート(p.4)」より引用

### 2005-07-18

本日は，数命令を実装しました．

作業内容

8ビットのシフト演算（ASL，ASR），補数演算，クリア命令を実装しました．
次回は，シフト演算（残），比較命令，分岐命令に，着手したいです．

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-05.gif" width="320px"/>

「MC6809Eデータシート(p.5)」より引用

### 2005-07-21

オーバーフローフラグの謎

INC命令，DEC命令等のOVフラグの実装が間違っているので修正しました．

簡単にまとめておくと，以下のようになります．

	加算の場合　	C=A+Bの時　OV=_(A^B) & (A^C) & 0x80（符号ビット）
	減算の場合　	C=A-Bの時　OV=(A^B) & (A^C) & 0x80（符号ビット）
	
	INCの場合　	C=A+1の時　
	 		OV=(_A & _B & C  |  A & B & _C) & 0x80（符号ビット）
			B=1(0x01)なので，B & 0x80=0(0x00)となり（同時に，_B & 0x80=0x80となり），
	 		OV=_A & C & 0x80（符号ビット）
	
	DECの場合　	C=A-1の時　
			OV=(_A & _B & C  |  A & B & _C) & 0x80（符号ビット）
			ここで，B=-1(0xFF)なので，B & 0x80=0x80となり（同時に，_B & 0x80=0(0x00)となり），
			OV=A & _C & 0x80（符号ビット）
	
	NEGの場合	C=0-Bの時
	 		OV=(_A & B & C  |  A & _B & _C) & 0x80（符号ビット）
			ここで，A=0(0x00)なので，A & 0x80=0(0x00)となり（同時に，_A & 0x80=0x80となり），
			OV=(B & C) & 0x80（符号ビット）

_(2021-10-16) この記載の理解には，初等的な論理演算の知識が必要です．_
__AはNOT Aを，A & BはA AND Bを，A | BはA OR Bを，A ^ BはA XOR Bを意味しています．_
_不明な場合は，読み飛ばしてください．_

作業概要

なお，本日の作業は，OVフラグ修正，算術命令（NEG命令，TST命令），シフト命令（LSL命令，LSR命令，ROL命令，ROR命令）を実装しました．
そろそろ，条件分岐命令を実装する予定です．

_(2021-10-16) 参考として，MC6809Eの[データシート](http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/)を共有します．_

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-06.gif" width="320px"/>

「MC6809Eデータシート(p.6)」より引用

### 2005-07-30

作業概要

本日は，比較命令，分岐命令（短分岐のみ）を実装しました．
明日は，分岐命令（長分岐），算術命令の残りを実装予定です．
もう少しで，8ビット系の命令（6800命令）が完了するかなという感じです．

総作業時間

2ヶ月 x 4週間 x 8時間 = 32時間

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-07.gif" width="320px"/>

「MC6809Eデータシート(p.7)」より引用

### 2005-08-01

本日の作業内容

分岐命令（長分岐），絶対ジャンプ命令を実装しました．

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-08.gif" width="320px"/>

「MC6809Eデータシート(p.8)」より引用

### 2005-08-10

作業概要

本日は，夏休みです．
6809エミュレータの続きを開発しました．
スタック関連を開発しました．
不勉強だったのですが，6809は，システム・スタック（Sレジスタ），ユーザ・スタック（Uレジスタ）の2本を持っているのですね．
さすが，究極の8ビットCPUですが，当時，私はZ80をやっていました．

_(2021-10-17) 当時，FM-7が6809を搭載していて，FM-7陣営は「6809は究極の8ビットCPU」という言説を流布していました．_
_アーキテクチャの美しさは，その後の68000にも受け継がれています．_

PSH命令，PUL命令，JSR命令，RTS命令等を実装しました．

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-09.gif" width="320px"/>

「MC6809Eデータシート(p.9)」より引用

### 2005-08-21

作業概要

今週は，8ビット系の残りの演算を実装しました．
具体的には，ANDCC命令，ORCC命令，DAA命令，EXG命令，TFR命令を実装しました．

BCD演算補正

DAA命令は，

	if ( Aレジスタの下位4ビットが10以上 || HフラグがON ) Aレジスタに0x06加算
	if ( Aレジスタの上位4ビットが10以上 || CフラグがON ) Aレジスタに0x60加算
	
	Cはリセットしないで，加算結果でNZCフラグ変更

というロジックで実装しました．

例えば，A = 0x99，B = 0x99，ADDA Bすると，A = 0x32，H=1，C=1になります．
ここで，DAAすると，A = A + 0x66 = 0x98，C=1になります．
この結果は，10進数での99+99=198と一致します（めでたし，めでたし）．

_(2021-10-17) BCD(2進化10進数)演算補正というのは，2進数で演算した結果を，10進数で演算したように補正する命令です．_
_よい子のみなさんは，基本情報技術者試験で習うかもしれません．_
_実務で使うことがあるかは不明です．_

レジスタ転送，交換

ポストバイトの上位下位4ビットによって，指定されるレジスタが違うので，そこのマクロをうまく組んで，実装しました．

次週以降の作業

今回で，8ビット演算系は，ほぼ終了です．
次回は，16ビット系（そんなに多くない），割り込み処理を実行する予定です．

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-10.gif" width="320px"/>

「MC6809Eデータシート(p.10)」より引用

### 2005-08-24

作業概要

本日は，16ビット系の演算を実装しました．具体的には，LDD命令，ADDD命令，SUBD命令などを実装しました．

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-11.gif" width="320px"/>

「MC6809Eデータシート(p.11)」より引用

### 2005-08-29

作業概要

本日は，16ビット系の演算を実装しました．
具体的には，ST[DUSXY]命令，LD[USXY]命令を実装しました．

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-12.gif" width="320px"/>

「MC6809Eデータシート(p.12)」より引用

### 2005-09-19

作業概要

本日は，16ビット系の演算を実装しました．
具体的には，CMP[DUSXY]命令，ABX命令を実装しました．

進捗しない理由

最近，あまり進捗していません．
実は，J2ME(Java 2 Micro Edition)向けに，UPnPスタックを書いていているのが，楽しくなって，そちらに時間を割いているためです．
まとまったら，リリースします．

_(2021-10-22) その後に，リリースされた形跡はありません．_

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-13.gif" width="320px"/>

「MC6809Eデータシート(p.13)」より引用

### 2005-09-22

作業概要

本日は，割り込み関連を実装しました．
具体的には，RESET，NMI，FIRQ，IRQ処理，RTI命令を実装しました．
次回は，ソフトウェア割り込みを実装予定です．
そこまでいけば，すべての機能を実装したことになるので，光速船のサンプルアプリを使って，6809の検証を始めます．

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-14.gif" width="320px"/>

「MC6809Eデータシート(p.14)」より引用

### 2005-09-23

作業概要

本日は，ソフトウェア割り込み関連を実装しました．
具体的には，SWI，SWI2，SWI3，CWAI，SYNC命令を実装しました．
これで，6809の機能は，すべて実装が，完了しました．
これから，1命令ずつ，検証をしていきます．

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-15.gif" width="320px"/>

「MC6809Eデータシート(p.15)」より引用

### 2005-09-24

作業概要

本日は，光速船のサンプルアプリを使い，6809の検証でした．
100クロック分までを検証しました．

- JSR命令の分岐先アドレス指定を修正
- PSHS命令，PSHU命令，PULS命令，PULU命令のアドレス増減を修正
- BPL命令，LBPL命令を追加
- MUL命令の絶対値指定（A，Bレジスタ）を修正

明日は，100クロック以降を検証します．

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-16.gif" width="320px"/>

「MC6809Eデータシート(p.16)」より引用

### 2005-09-25

作業概要

本日は，光速船のサンプルアプリを使い，6809の検証でした．
2200クロック分までを検証しました．

- BRA命令，LBRA命令のFALSE時の処理を修正
- ST[ABDSUXY]命令で，アドレス指定を修正

来週は，2200クロック以降を検証します．

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-17.gif" width="320px"/>

「MC6809Eデータシート(p.17)」より引用

プログラム名

名前は，InfoVectrexにしようかなと思ってます．
InfoKousokusenも考えたのですが．

### 2005-10-02

作業概要

今週も，光速船のサンプルアプリを使い，6809の検証でした．
2500クロック分までを検証しました．

- インデックスアドレッシングでの5ビットオフセット処理を修正
- CMP[AB]命令のキャリフラグ処理を修正

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-18.gif" width="320px"/>

「MC6809Eデータシート(p.18)」より引用

ウェイト

2468クロック辺りから，以下のようなコードでウェイトに入っています．

	B=$40  DP=$D0
	
	F33D  D50D        BITB   <$0D   
	F33F  27FC        BEQ    $F33D

つまり，$D00Dに，$40等が書き込まれるまで，ループを待ち続けることになります．
では，誰が，$D00Dに値を書くかというと，当然CPUではなく，それ以外のHWということになります．
ちなみに，D00Dは，6255VIAの領域になります．

次週以降

6809の検証は，まだ必要という感触なので，$D00Dを読み込むとダミーの値を返すようにして，引き続き6809の検証を続けていきたいです．
まだまだ，バグバグという感じです．

### 2005-10-07

作業概要

本日は，$D00Dを読み込んだとき，$40をダミーで返却するようにして，6809の検証でした．2600クロック分までを検証しました．

- 修正点なし

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-19.gif" width="320px"/>

「MC6809Eデータシート(p.19)」より引用

### 2005-10-08

作業概要

本日は，2700クロック分まで，6809を検証しました．だいぶ繰り返しになってきたので，明日以降は，6809以外の部分の実装を始めようかと思っています．

- 修正点なし

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-20.gif" width="320px"/>

「MC6809Eデータシート(p.20)」より引用

### 2005-10-08

調査報告（その1）

先週末，6809エミュレータの検証が，ほぼ完了しましたので，CPU以外のモジュールを設計，開発していきたいと思います．通常，エミュレータでは，CPUの次は画面系になりますが，光速船ではベクタースキャンという特殊な方法で，画面を描画しているので，そこら辺について調査しましたので，報告します．

6522A VIA

光速船では，CPUとベクトル描画モジュール間の通信は，6522A VIA経由で実現されます．したがって，CPUからみると，6522A VIAを制御することで，ベクトルを描画することができるわけです．それでは，BIOSが，どのようにベクトル描画モジュールを制御しているかを解析しつつ，その動作を理解していきましょう．

初期化

まず，BIOSは，VIA_aux_cntlレジスタ（$D00B）に，$98を書き込むことで，ベクトル描画モジュールを初期化します．それぞれのビットの意味は，以下の通りです．

|ビットマスク$98|値|VIA_aux_cntlレジスタでの意味|
|:------------:|:--:|:----------------------:|
|ビット7|1|タイマT1からPB7への出力を有効にする|
|ビット6|0|タイマT1は1度で停止（ワンショット）|
|ビット5|0|タイマT2は1度で停止（ワンショット）|
|ビット4<BR>ビット3<BR>ビット2|1<BR>1<BR>0|110=CB2への出力は2相クロックで制御（モード4）|
|ビット1|0|PBラッチを使わない|
|ビット0|0|PAラッチを使わない|

なんだか，よく分からないですが，注目すべきこととしては，2点あります．

1つは，シフトモード（ビット2-4）です．シフトモードは，モード4に設定されます．光速船では，モード4以外は使いません．6522A VIAは，8ビットのシフトレジスタを持っています．モード4では，シフトレジスタへなにかを書き込むことで，有効にできます．しかも，ローテートでシフトされるので，ビット7は，ぐるっと廻って，ビット0に戻ってきます．そのため，8シフト以降も，シフトは続きます．また，シフトは，システムクロックの半分の速度で実行されます．重要なのは，シフトで追い出されたビットが，CB2（~BLANK）に入るということです．~BLANKは，0でアクティブです．もし，~BLANKが，0であれば，ビームは出力されません．

もう1つは，タイマT1がアクティブ時に，PB7への出力を有効にするビット（ビット7）です．PB7というのは，~RAMP信号と呼ばれており，0でアクティブです．PB7（=~RAMP）がセット時には，ビームが移動します．

（この続きは，調査報告（その2）に記述します）

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-21.gif" width="320px"/>

「MC6809Eデータシート(p.21)」より引用

### 2005-10-16

作業概要

本日は，6522A VIAチップについて，レジスタとそれらを操作するためのマクロを記述しました．明日は，タイマー等の実際の動作について記述したいと思います．調査報告（その２）は，また別途にします．

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-22.gif" width="320px"/>

「MC6809Eデータシート(p.22)」より引用

### 2005-10-23

作業概要

本日は，6522A VIAのタイマーT1，T2を実装しました．光速船のサンプルプログラムを使って，メモリマップI/Oでタイマーに値がセットされ，クロックに同期して，カウントされて，0になると停止することを確認しました．

T2の方は，システムクロックに同期するものと，PB6に同期するものがあるのですが，光速船では使ってない（と思う）ので，実装していません．また，T1がカウントしている間に，~RAMPに信号を出す部分も正しく動作していることを確認しました．

来週は，ベクトル描画器に値を設定するところなどを，実装する予定です．課題としては，CPUと6522Aの同期をどうするかということです．やはり，ベクトル描画器を中心に，6522A，CPUを制御するモデルの方が，よいのかもしれないです．

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-23.gif" width="320px"/>

「MC6809Eデータシート(p.23)」より引用

### 2005-11-26

いろいろと忙しく，だいぶご無沙汰していました．この間に若干作業をしたので，その報告です．

(1) CPUとベクトル発生器（VG: Vector Generator）の連携

ハード的には，別々なので，同時に動作するのですが，それをエミュレーション（ソフト）で実現するためには，CPUとVGがどう連携するかを考えないといけません．今回の実装として，以下のような方針で行こうかなと考えています．

- メインループ
  - 1/60秒（1画面）分のエミュレーション実行
    - CPUエミュレーション（1命令），メモリアクセス（I/O）
    - CPU 1命令に対応するVGエミュレーション（※）
    - CPU 1命令に対応する6522（VIA 6522A）エミュレーション
  - 古い画面の消去，新しい画面の表示（※）

現時点で，（※）の部分以外までは，実装しました．

(2) VGエミュレーションの一部

VGは，ビームを動かす目標を，Xレジスタ，Yレジスタ（6809のとは別）によって，保持しています．その値は，メモリマップI/Oで，6522経由でセットされます．その部分のエミュレーションを実装しました．

(3) 実験

この段階で，1画面分のエミュレーションに挑戦してみました．画面上にはなにも現れませんが，Xレジスタ，Yレジスタに書き込まれる値で，画面が想像できると思います．

<img src="http://www.playvectrex.com/designit/chrissalo/coord.gif" width="320px"/>

「PlayVectrex.com」より転載

以下のように変化しました．

	X,Y,シフトレジスタ
	127,127,0
	-128,-128,0
	0,-128,0
	14,-128,0
	0,-128,0
	13,-128,0
	1,-128,0
	12,-128,0
	1,-128,0
	11,-128,0
	1,-128,0
	10,-128,0
	1,-128,0
	9,-128,0
	1,-128,0
	8,-128,0
	1,-128,0
	7,-128,0
	1,-128,0
	6,-128,0
	1,-128,0
	5,-128,0
	1,-128,0
	4,-128,0
	1,-128,0
	3,-128,0
	1,-128,0
	2,-128,0
	1,-128,0
	0,-128,0
	...

ただ，最初の1画面分では，シフトレジスタの値がすべて0なので，ビームが動くだけで，画面にはなにも出力されません．もう少しクロックを進めると，シフトレジスタに値（0xe0等）が書き込まれるので，なにか表示されることになります．

画面にはかけていませんが，ビームが動き出しましたよ！！

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-24.gif" width="320px"/>

「MC6809Eデータシート(p.24)」より引用

_(2021-10-23) 174日目です．2005年6月5日に開始で，2005年11月26日分までリマスタしました．_
_6809命令の実装がほぼ終わりました．_
_半年間は，延々と6809の命令を書いてたことになるので，地味ですね．_
_3月までは，ネットワーク科学という学問にはまって，ほぼ放置になります．_

### 2006-03-30

その他

光速船エミュは，6809を書き終わった時点で，楽しみのピークを過ぎてしまったので，ペンディングです．6809のところまでをリリースするかもです．

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-25.gif" width="320px"/>

「MC6809Eデータシート(p.25)」より引用

_(2021-10-23) 例年この時期は仕事の方がが忙しくて，趣味の方に手が付けられなかったのだと想像します．_
_また，同じ時期に，ネットワーク科学という新しい分野に興味を持ち，本を数冊読んでいます．_

### 2006-04-14

これまでの経緯

昨年の春頃から，光速船エミュを作り始めて，秋頃までに，

- CPU(6809)　ほぼ完了
- PIA（6522)　タイマーのみ（半分ぐらい？）
- ベクトル生成器　ほとんど未

ぐらいまで作りました．そこで，複雑系の本とかを調べ始めたりして，さぼってたのですが，今日，また，気まぐれでいじりました．

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-26.gif" width="320px"/>

「MC6809Eデータシート(p.26)」より引用

進捗

(1) CPUから入力をPIAにつなぐMUXの動作を勘違いしていたので修正

	0 - Y Axis integrator channel
	1 - X,Y Axis integrator offset
	2 - Z Axis (Vector Brightness) level
	3 - Connected to sound output line via divider network

1の意味が分からなかったのですが，オフセットだったのですね．なので，DX = X - Offset，DY = Offset - Yです．DX，DYは，ビームの移動速度です．

(2) ~RAMPに対応

~RAMP信号は，0アクティブなのですが，アクティブ時にしか，ビームが動きません（DX = DY = 0）．

(3) ~ZEROに対応

~ZERO信号は，アクティブになると，ビームが中心に戻ります．

結果

ここまでで，やっと，ビームが動き始めて，矩形（四角）が描かれました．でも，ビルトインのフォントで文字を書くところで，おかしくなっているので，確認していきます．

### 2006-04-16

昨日，シフトレジスタ周り等，VIA R6522に関する調査，コーディングが，足りないということが分かりました．そこで，少しVIA R6522について調査することにしました．

- [PlayVectrex - Appendix C](http://www.playvectrex.com/designit/chrissalo/appendixc.htm)
- [JR-100](http://www.asamomiji.jp/antique/JR100/software.html)

JR-100のコントローラも，R6522だったのですね．

追伸

メガドライブの方は，しばらくお休みです．まず，R6522をなんとかしましょう．

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-27.gif" width="320px"/>

「MC6809Eデータシート(p.27)」より引用

### 2006-04-23

先週から引き続き，R6522の調査．今週末も，ある意味，多忙で，進捗芳しくないですが，分かったことをまとめておきます．

参考文献

- [R6522 VERSATILE INTERFACE ADAPTER](http://www.playvectrex.com/designit/chrissalo/via2.htm)

調査結果

|タイマ名|モード名|説明|
|-------|-------|----|
|T1タイマ|one-shotモード|参考文献の図15にチャートがありますが，T1C-Hに値を書き込まれると，カウンタのディクリメントが開始されます．それと同時に，PB7（=~RAMP）が0（=アクティブ）になります．そして，カウンタが0になって，0.5クロック過ぎた時点で，1（=非アクティブ）にもどります．そして，同時に，~IRQも1に戻ります．|
|T1タイマ|free-runningモード|図16にチャートがありますが，T1C-Hに値を書き込まれると，カウンタのディクリメントが開始され，それと同時に，PB7が0になるまでは同じです．ただ，カウンタが0になると，ラッチ（T1L-H，T1L-L）にある値が，カウンタ（T1C-H，T1C-L）に転送され，再度カウントが開始されます．そして，PB7は，カウンタが0になる度に，反転するので，結果として，N+1.5とN+2という周期を持った，矩形波が出力されます．|

ただ，光速船では，使われてないと思います．（その２９へ続く）

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-28.gif" width="320px"/>

「MC6809Eデータシート(p.28)」より引用

### 2006-04-29

参考文献

- [R6522 VERSATILE INTERFACE ADAPTER](http://www.playvectrex.com/designit/chrissalo/via2.htm)

今週は，早起きをして，朝1時間ぐらい開発しました．GWも早起きして，シフトレジスタあたりから，作業します．

進捗状況

|日付|概要|詳細|
|----|----|----|
|2006/4/24|* R6522レジスタ（タイマT1，T2関連）|タイマT1，T2関連のレジスタの動作は，以前からもコーディングしてあったのですが，内容確認です．若干，勘違いもあったので，修正しました．|
|2006/4/25|* T2タイマ修正（one-shotモード）<br>* T2タイマ残（PB6モード）|T2タイマのone-shotモードの修正．例えば，T2タイマに，Nを書き込んだとき，実際には，N+1.5クロックで終了するので，+1.5クロックになるように修正とか．PB6モードは，PB6に印加されるクロックでタイマを動作させるモードですが，光速船ではありえないので，コーディング残です．R6522エミュレータとしての互換性向上のためには必要です．|
|2006/4/26|* T1タイマ修正（one-shotモード，free-runモード）|T1タイマの修正．free-runモードで，PB7への出力がトグルになって，矩形波が出力されるところなど．光速船では，使わないんですが，念のため．|
|2006/4/28|* Port B修正（書き込み，読み込み）|書き込み時，読み込み時の動作をコーディングしました．DDRBの結果が反映されるようにとか，ORB/INBなどの動作もより正確にしました．|
|2006/4/29|* Port A修正（書き込み，読み込み）|同上です．|

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-29.gif" width="320px"/>

「MC6809Eデータシート(p.29)」より引用

### 2006-05-03

進捗状況

GW1日目の進捗は，以下の通りです．

|日付|概要|詳細|
|----|----|----|
|2006/5/3|* シフトレジスタ（SR）モード#6<br>* シフトレジスタ（SR）モード#0|モード#0は，SR Disableなので，なにもしなくてもOKでした．<br>光速船で，使われているのが，モード#6で，O2クロックに同期して，shift outするモードです．O2クロックとは，システムクロックです．詳細は，省きますが，実際には，O2クロックの1/2の速度で，シフトが起こります（2クロックに1回）．そして，shift outなので，最上位ビットが，1の時には，~BLANKをHIに，0の時には，LOWに変化させます．|

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-30.gif" width="320px"/>

「MC6809Eデータシート(p.30)」より引用

### 2006-05-05

進捗状況

|日付|概要|詳細|
|----|----|----|
|2006/5/5|* シフトレジスタ（SR）モード#2<br>* シフトレジスタ（SR）タイミング修正<br>* モード#1，#3，#4，#5，#7残|モード#2は，モード#6のshift outをshift inするだけで，すぐに実装できました．モード#2，#6のタイミングが，ずれていたので，修正しました．<br>モード#1，#3，#4，#5，#7は，T2の下位バイト（ラッチ）をカウンタにして，シフトするというモードなのですが，光速船では出てこないので，とりあえず残にしておきます．|

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-31.gif" width="320px"/>

「MC6809Eデータシート(p.31)」より引用

### 2006-05-07

進捗状況

|日付|概要|詳細|
|----|----|----|
|2006/5/7|* IFR修正（書き込み，読み込み，IRQピン対応）<br>* IER修正（書き込み，読み込み）<br>* SR割り込みフラグ動作修正<br>|R6522のドキュメントの最後にあるINTERRUPT OPERATIONの章に書いてある内容を実装しました．CA1，CA2，CB1，CB2のACTIVE EDGEの時に，割り込みフラグがセットされる部分は，多分，光速船では使われないと思い，残にしました．<br>これで，R6522は，残になっている部分を除いて，すべて実装完了しました．GW中に，ここまでと思っていたので，最低限は終了しました．来週は，ベクトル生成器の実装をすすめます．|

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-32.gif" width="320px"/>

「MC6809Eデータシート(p.32)」より引用

### 2006-05-08

スクリーンショット

現在，CPU，R6522，ベクトル生成器（一部）の実装が終わっているのですが，まだ，画面系はなにも実装していません．ただ，ビームが動いた座標と輝度をテキストで表示するところまでは，作りました．それを，EXCELのグラフウィザードに入力すると，以下のような画面が出てきました！！　なんとなく，正しい座標が出ているみたいです．

![](https://github.com/jay-kumogata/InfoVectrex/blob/master/screenshots/kousokusen_060508_1.PNG)

進捗状況

GW最終日，少し頑張りました．

|日付|概要|詳細|
|----|----|----|
|2006/5/8|* VG: ~RAMP信号動作を修正<br>* CPU: BNE命令，LBNE命令を修正<br>* CPU: TRF命令を修正<br>|6809にまだバグがあったみたいなので，1つ1つつぶしていきます．今週は，ベクトル生成器の実装です．|

_(2021-10-24) 337日目．_
_ベクトルグラフィックス関連のチップ実装が終わったところです．_
_座標を数字で表示して，excleグラフにして画面を表示しています．_
_枠が少しずれていますが，最初にしては上出来です．_
_最初に画面が出た時が最も興奮する瞬間です．_
_それまでの地味な作業が報われて，リリースが見える瞬間でもあります．_

### 2006-05-14

スクリーンショット

先週，まわりのラインが崩れていましたが，今週の懸命な(?)作業で，1画面目が正しく表示されました．想定では，この画面がしばらく何度も描画されるため，来週は，グラフィックスを使って画面描画するルーチンを描画したいと思います．

![](https://github.com/jay-kumogata/InfoVectrex/blob/master/screenshots/kousokusen_060514_1.PNG)

進捗状況

|日付|概要|詳細|
|----|----|----|
|2006/5/13|* CPU: DEC命令，INC命令，NEG命令を修正（Zフラグ）<br>* VG: Multiplexer修正<br>* Memory: Port B，A修正（書き込み）|DEC命令で，メモリ領域を直接ディクリメントするときの，Zフラグの立ち方が，間違っていたので，修正しました．同じ間違いが，INC命令でも，NEG命令でもあったので，修正しました．これで，ビームが画面外に出るバグが修正されました．|
|2006/5/14|* M6522: _RAMP信号を修正（PB7_OUTフラグ動作）|~RAMP信号として，PB7_OUTフラグが真の時には，T1割り込みフラグの値を，偽の時には，PB7の値を使うようにしました．当然，~RAMP信号がアクティブのときしか，ビームは動きません．<br>つまり，ビームを動かす時に，T1タイマを使う（PB7_OUTフラグを使う）方法と，直接PB7をいじる（PB7_OUTフラグを使わない）方法があるわけですね．|

### 2006-05-17

実機画面

実機の起動画面（左）が，[ネット上](http://vectrex.takuranke.com/vectrex_info.html)にありました．開発中のエミュレータのスクリーンショット（右）と比較してみましょう．

<img src="http://vectrex.takuranke.com/pic/etc/KOUSOKUSEN_STARTUP.jpg" width="320px" />
<img src="https://github.com/jay-kumogata/InfoVectrex/blob/master/screenshots/kousokusen_060514_1.PNG" width="320px" height="446px" />

技術情報

この文書（通称：internal.txt）が，光速船について，一番詳しい情報です．ポイントになるところを訳してみました．

- Vectrex HP3000 Programming Notes

日本語訳

6522A

このデバイスは，光速船の周辺デバイス（例：キーパッド，ベクトル生成器，DAC，サウンドチップ，等）を，すべて制御するために使われています．

ポートAは，バスとして使われており，DACへの入力，および，サウンドチップへの入力ピンD0-D7に直接つながっています．
DACは，このポート上にある値であれば，どんなものでも出力します．

ポートBは，以下のように使われています．

|信号名|説明|
|------|----|
|PB0 - SWITCH　|スイッチ制御は，アナログ・マルチプレクサを有効化／無効化．ベクトル描画ハードウェアの記述を見て下さい|
|PB1 - SEL0　　|マルチプレクサのチャンネル選択を制御します|
|PB2 - SEL1　　|ベクトル描画ハードウェアの記述を見て下さい|
|PB3 - BC1 　　|訳注：動作を正しく理解していないので，訳していません|
|PB4 - BDIR||
|PB5 - COMPARE||
|PB6 - ???||
|PB7 - ~RAMP 　|このラインは，ベクトル描画ハードウェアの一部を制御します．アクティブロー信号です|

6522Aは，いくつかの制御線を持っています．
これらの制御線は，ハンドシェークするために使われたりするが，光速船では，ベクトル描画ハードウェアを制御するために使われています．

|信号名|説明|
|------|----|
|CA1 - IO7　　|訳注：動作を正しく理解していないので，訳していません|
|CA2 - ~ZERO　|ベクトル描画ハードウェアの一部を構成する積分器に接続します．この制御線は，それらの積分器を0にして（X，Yとも），ビームをCRT中央に戻す効果があります．アクティブロー信号です．詳細な情報は，ベクトル描画ハードウェアの記述を見て下さい|
|CB1 - |未接続|
|CB2 - ~BLANK |このアクティブロー信号は，ベクトル描画ハードウェアへのビーム信号をオン／オフさせます．再描画のために，ビーム位置を変更する時に，ビームを消すのに使われます|

### 2006-05-19

技術情報

前回（その３５）に引き続きで，ポイントになるところを訳しました．

- Vectrex HP3000 Programming Notes

日本語訳

ベクトル描画ハードウェア

（訳注：仕様と直接関係ないため，訳していません）

ベクトル描画回路は，アナログ／デジタル混合回路であり，以下のパーツから構成されています．以下の文書で，制御線（機能）をセット／クリアするという記述があった時には，その機能に対応するハードウェアのセットアップ方法が記述されている箇所に戻って参照してください．

(1) DAC. (デジタル／アナログコンバータ)

DACは，ベクトル部において，最も重要なパーツです．DACは，6522のポートAに直接接続されています（ポートAをセットアップ，書き込みする詳細な方法については，6522Aの記述を見て下さい）．DACは，8ビットのデジタル値を取り，その値に比例したアナログ信号へ変換します．

	DAC出力ボルト = ( ポートA - オフセット ) x 定数

DACの出力は，?.??ボルト単位で，+?.??ボルトから-?.??ボルトの値域を持ちます．

DACにはイネーブル制御が存在しないので，入力された値は，すべて変換されることに注意して下さい．DACの出力は，マルチプレクサへの入力，および，X軸の積分器の入力へ接続されています．DACへの入力であるポートAは，AY-3-8192にも接続されているので，サウンドチップへの書き込み時には，BLANK，RAMP信号のいずれか/両方が，アクティブ化しないように注意して下さい．さもなければ，CRT全体にごみを描画してしまうかもしれません．

(2) マルチプレクサ（デジタル／アナログ混合）

DACの出力は，マルチプレクサの入力へつながっています（マルチプレクサICの半分は，この目的で使われており，もう半分は，ジョイパッドの電位差計のA/D変換に使われています）．マルチプレクサは，1入力を取り，4出力のうちに，1出力を選んで切り替えます．入力信号は，同時に1つの出力信号としかつながりません．

マルチプレクサは，3制御入力を持っています．1つ目は，6522AのSWITCH線（ポートBのビット0に対応）です（このビットをセット／クリアする方法は，6522Aの記述を見て下さい）．この制御線をアクティブ化すると，ちょうど，機械式のスイッチが動かされるように，入力ピンが選択された出力ピンに接続されます．また，非アクティブ化されると，入力と出力ピンは，お互いに完全に分離されます．

2つ目は，SEL0，SEL1の入力（それぞれ，6522のポートBのビット1，2に対応）です．ビット1，2は，結合されて，2ビットの数（0-3の範囲を示す）になります．マルチプレクサがアクティブ化された時（上記を参照）には，ビット1，2の入力は，どの出力ピンが入力ピンに接続されるかを決めるのに使われます．ベクトル・マルチプレクサで使われるピン／チャネル番号は，以下で与えられます．

|ピン／チャネル番号|説明|
|--------------|----|
|0 - Y軸積分器チャネル||
|1 - X軸，Y軸積分器のオフセット|訳注：上記の式のオフセットのことです|
|2 - Z軸（ベクトル輝度）レベル|訳注：ベクトルの明るさのことです|
|3 - |訳注：動作を正しく理解していないので，訳していません|

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-33.gif" width="320px"/>

「MC6809Eデータシート(p.33)」より引用

### 2006-05-20

技術情報

前回（その３６）に引き続きで，ポイントになるところを訳しました．

- Vectrex HP3000 Programming Notes

日本語訳

X軸積分器，Y軸積分器（アナログ）

それぞれの積分器への入力の前に，アナログスイッチが存在します．このスイッチは，6522AのポートBのビット7から出ているRAMP信号に接続しています．スイッチが閉じている（RAMP=0）時には，積分器は入力されている値を積分していきます．RAMPが非アクティブ化され，スイッチが開くと，積分動作は行なわれず，積分器は現在の値を保持し続けます（ZERO機能を見て下さい）．出力は，以下のような形式にしたがいます．

	出力値Vout = ( -1 / CxR ) ∫( 入力値Vin - オフセット値Voffset ) dT + 定数

X軸，Y軸積分器については，R=10000，C=0.01x10E-6となります．

この値を代入すると，以下の通りです．

	出力値Vout = - ((10000 x (入力値Vin-オフセット値Voffset) x 積分時間) + 初期値)

最大偏向電圧を+5Vから-5Vと仮定すると，ビームの動きを計算できます．これは，常に，前回のビーム位置からの相対的な動きです．したがって，ビームがどこに位置しているかを確認するためには，まず積分器をゼロ（ZERO）にすることでしか，確実に0,0に位置していることが確認できません．

	入力値（整数）IntInput  = (DAC値 - 128) * (10/256)
	オフセット値（整数）IntOffset = (DAC値 - 128) * (10/256)

ここで，10/256は，最大の振幅が10ボルトとし，それを256ステップで分割して求められます．したがって，1ステップは，10/256ボルトです．-128するのは，DAC値をプラス／マイナスの値に変換するためです．

	⊿X = - ((10000 x (IntInput-IntOffset) x 移動時間RAMPtime) 
	(or Y)
	X = X + ⊿X

光速船で利用できるスクリーン領域を8インチ（20.3センチ）と仮定します．これが，10ボルトの振幅と同じになります．

（訳注：仕様と直接関係ないため，訳していません）

	X軸の位置 = X (ボルト) * 2.03 (センチ/ボルト)
	(or Y)

この値は，またスクリーンの中心を0,0として参照しています．

積分器への電力供給は，+5ボルトから-5ボルトのアナログの電力供給です．いかに長く積分したとしても，供給限界を超えることはできません．つまり，非常に長く積分した時には，積分器は飽和します．大抵，積分時間，つまり，RAMP信孫がアクティブになっている時間は，とても短くて，マイクロ秒かミリ秒のオーダーです．

では，振幅のすべて（10ボルト）を移動するのには，どのぐらい時間がかかるのでしょうか．オフセット値=0，初期値=0，飽和なしと仮定します．

	10 = - 10000 x -10 x 積分時間
	積分時間 = 100μs=0.1ms

これは，画面の一方からもう一方までにまたがる，最大のベクトルを描画するものです．

	出力値Vout = X軸，Y軸の両方において-5Vから+5V

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-34.gif" width="320px"/>

「MC6809Eデータシート(p.34)」より引用

### 2006-05-21

スクリーンショット（左から，No.1，2，3）

<img src="https://github.com/jay-kumogata/InfoVectrex/blob/master/screenshots/kousokusen_060521_1.PNG" width="320px" />
<img src="https://github.com/jay-kumogata/InfoVectrex/blob/master/screenshots/kousokusen_060521_2.PNG" width="320px" />
<img src="https://github.com/jay-kumogata/InfoVectrex/blob/master/screenshots/kousokusen_060521_3.PNG" width="320px" />

No.1，2までは，実機と同じ画面なので，問題ありません．ただ，No.3で画面上部に0が表示されるのは，実機と異なります．実機では，Player 1と表示されます．この時点で，コントローラの接続状況等を確認しているのかもしれないですが，正しくエミュレーションできていないので，次の画面へ遷移できていません．

進捗状況

|日付|概要|詳細|
|----|----|----|
|2006/5/20|* Win32: ウィンドウ処理を追加<br>* Win32: 画面更新（ライン描画）を追加|InfoChip8を参考にして，ウィンドウ上に画面が表示されるようにしました．また，Windows GDIを使って，グラフィック描画ルーチンをコーディングしました．|
|2006/5/21|* Win32: 画面更新（ライン描画）を修正||

画面更新のタイミングは，50Hz（6809（1.5MHz）の30000サイクル分）としました．したがって，処理的には，以下のようなループを回しています．

- (1) CPU，6522A，ベクトル描画器を，30000サイクル動かす
- (2) 画面更新
- (3) (1)へ戻る

来週の予定

画面上に，0が表示される原因を突き止めて，次の画面（Player 1）が表示されるように頑張ります．

### 2006-05-28

スクリーンショット（左から，No.4，5）

<img src="https://github.com/jay-kumogata/InfoVectrex/blob/master/screenshots/kousokusen_060527_1.PNG" width="320px" />
<img src="https://github.com/jay-kumogata/InfoVectrex/blob/master/screenshots/kousokusen_060527_2.PNG" width="320px" />

コントローラ処理を追加，CPUバグを修正しました．それにより，No.4，5の画面が表示されました．しかし，No.5直後に，画面がブラックアウトします．CPUバグの可能性を疑っています．

進捗状況

|日付|概要|詳細|
|----|----|----|
|2006/5/27|* VG: Joystick方向処理を追加<br>* SG: Joystickボタン処理を追加<br>* CPU: PULS命令，PULU命令を修正|Joystickの方向処理，ボタン処理を記述しましたが，Windowsからの情報取得は未コーディング．ただ，コントローラのチャックは，パスしたみたいで，次の画面へ遷移しました．途中，CPUのバグで，PULS命令のレジスタへの書き戻し順序が間違っていたので，修正しました．|

来週の予定

ブラックアウトする原因を突き止めて，No.5の描画が完了ように修正します．

### 2006-06-04

スクリーンショット（左から，No.4，5）

<img src="https://github.com/jay-kumogata/InfoVectrex/blob/master/screenshots/kousokusen_060527_1.PNG" width="320px" />
<img src="https://github.com/jay-kumogata/InfoVectrex/blob/master/screenshots/kousokusen_060527_2.PNG" width="320px" />

今週は，IP unreachableな環境にいたため，進捗はゼロです．寂しいので，先週のスクリーンショットを再掲しておきます．

_(2021-10-30) 当時は，smartphoneもなかったので，旅行等に出かけると，即座にIP unreachableな環境に身を置くことができました．_

技術情報

暇をみて，日本語訳していたものをリリースします．

- Vectrex HP3000 Programming Notes

日本語訳

(4) RAMP (デジタル，アクティブロー)

上述の通り，RAMP信号は，積分器の積分時間を制御します．この制御線は，アクティブロー信号で，6522のポートBビット7に接続しています．

(5) ZERO (デジタル，アクティブロー)

この制御線は，6522 CA2線に接続されています．この制御線をどのようにセットアップするかの情報は，6522の記述を見て下さい．RAMP同様に，これもアクティブロー信号です．積分動作中には，この制御線は，非アクティブ状態（HIGH）にセットされなければなりません．

この制御線がアクティブになると，積分器の出力は0Vにセットされ，ビームは画面中央に移動します．線描画シーケンスとして，積分器に値を書き込む前には，この制御線をアクティブ化すべきです．積分器の出力値は，小さなコンデンサに保持され，すこしずつ放電していきます．つまり，ある一定の時間以上，積分器がRAMPモードにある時には，その出力はゆっくりとゼロに落ちていきます．したがって，一通りのベクトルを描画した後には，確実に座標を取得するために，一度ゼロにクリアするべきです．

(6) Z座標信号(アナログ)

この信号は，CRTのZ座標（輝度）を制御しています．この信号は，マルチプレクサをZ座標の設定にし，DACへ値を書き込むことでセットできます．また，この信号は，サンプル＆ホールド回路に接続されているので，マルチプレクサを切り離したとしても，値を保持することができます．

積分器と同様に，サンプル＆ホールドも，ゼロに向かってゆっくりと移動するので，ときどき，再書き込みする必要です．もし，一定の明るさで描画したいのであれば，それぞれのオブジェクトを描画するたび，もしくは，画面リフレッシュのたびに，この値を書き込むというのが，よい考えです．もちろん，ベクトルごとに明るさを変えたいのであれば，とにかくそのたびに値を書き込まなければなりません．

<img src="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6809/6809-35.gif" width="320px"/>

「MC6809Eデータシート(p.35)」より引用

### 2006-06-10

技術情報

暇をみて，日本語訳していたものをリリースします．

- Vectrex HP3000 Programming Notes

日本語訳

(7) BLANK (デジタル，アクティブハイ)

CRTビームの輝度を変更せずに，画面上の位置を変更するには，この制御線を利用し，一時的に，Z座標の信号をゼロにできます．このZ座標の信号を非アクティブ化した時には，前の値が復元されます．

まとめ

（直接関係ないので，訳していません）

ベクトル描画の方法

いままでの記述を読んだのであれば，すでにベクトル描画についてよい考えが浮かんでいるとはずです．もしくは，本当に，これに興味がないのであれば，ここを飛ばして結構です．ベクトル描画の流れを以下に示します．

	ステップ1 BLANKビットを0にセット．スクリーン上にゴミを垂れ流さないようにするためには，
	　　　　  これがセットされていなければならない
	　　　　2 ZEROビットを0にセットし，積分器をクリア
	　　　　3 RAMPビットを1にセット	
	　　　　4 ZEROビットを1に戻す
	　　　　5 マルチプレクサを有効にして，Z座標を選択
	　　　　6 ベクトルの輝度をDAC書き込み
	　　　　7 X，Y座標の積分器オフセットを選択し，DACに値を書き込む．
	　　　　  この値を使うと，X，Y座標を上下左右に動かすことができる

...

### 2006-06-11

スクリーンショット（左から，No.6，7，8，9）

![](https://github.com/jay-kumogata/InfoVectrex/blob/master/screenshots/kousokusen_060610_1.PNG)
![](https://github.com/jay-kumogata/InfoVectrex/blob/master/screenshots/kousokusen_060610_2.PNG)
![](https://github.com/jay-kumogata/InfoVectrex/blob/master/screenshots/kousokusen_060610_3.PNG)
![](https://github.com/jay-kumogata/InfoVectrex/blob/master/screenshots/kousokusen_060610_4.PNG)

先々週の予想通り，CPUのバグを直したところ，一通り（No.6，7，8，9），エミュレーションが動くようになりました．実際には，ゲームオーバになって，再度，タイトルが表示されるところまで確認しています．

進捗状況

|日付|概要|詳細|
|----|----|----|
|2006/6/10|* CPU: LSRB命令を修正(CK=941，FRAME=1145)|LSRB命令で，処理結果をAレジスタに入れるという馬鹿なバグでした．<br>明日以降は，画面描画処理の高速化，ちらつきを抑える，コントローラ処理の追加をします．そこまでいくと，一応，ゲームが動くレベルになるので，リリースするかもしれません．|

### 2006-06-14

技術情報

暇をみて，日本語訳していたものをリリースします．

- Vectrex HP3000 Programming Notes

日本語訳

ベクトル描画の方法

	---->　　8 この動作が描画（DRAW），もしくは，位置変更（POSITION）のいずれかによって，BLANK線をセットする
	|　　　　  （訳注：描画の時に，BLANK線をセットする）
	|　　　　9 マルチプレクサ上でY座標を選択し，DACに対して，Y方向の速度を書き込み
	|　　　　10 マルチプレクサを無効にする
	|ループ　11 DACに対して，X方向の速度を書き込み
	|　　　　12 RAMP線を1にセット
	|　　　　< ここで，ベクトルが描画される >
	 ----　　13 RAMP線を0にセット
	 　　　　< ベクトルが終了 >
	 　　　　14 CRT上になにも描画しないためには，BLANK線に0をセット

上記のステップは，それぞれのオブジェクト，もしくは，画面全体について，1ループで実行されます．EXEC ROMが，どのような動作をしているかは分からないが，私としては，それぞれのオブジェクト毎に，ステップ1-14を実行しています．つまり，ループ8-13は，そのオブジェクトのコンポーネント毎の実行します．最後に描画したオブジェクトを参照する（相対座標）よりも，原点を参照する（絶対座標）ほうが，各オブジェクトの位置を確実に決めることができます．もし，ゼロ化をしないと，エラー発生時に，オブジェクトが，ぐらぐらしたり，揺れたりするかもしれません．

### 2006-06-18

スクリーンショット（左から，No.10，11）

![](https://github.com/jay-kumogata/InfoVectrex/blob/master/screenshots/kousokusen_060618_1.PNG)
![](https://github.com/jay-kumogata/InfoVectrex/blob/master/screenshots/kousokusen_060618_2.PNG)

キー入力を受け付けるようなったので，ゲームができるようになりました．ただ，画面描画ルーチンが，だめだめなので，画面がちらついてしまいます．

進捗状況

|日付|概要|詳細|
|----|----|----|
|2006/6/18|* Win32: Joystick #1の処理を追加<br>* VG: Joystick比較処理を修正（比較結果を保持）|Joystickの比較結果は，ORBに反映しないで，内部で持っていて，ORBの読み込み時に併せて出力するというのが，正解でした．|

今後の予定

あとは，暫定で作った画面描画ルーチンを，作り直しするところが，来週以降です．今日は，サッカーのため，夜はなにもしません．

_(2021-11-01) 当時，男子サッカーの国際試合は，重要なイベントでした．テレビで応援するために，なにもできないという意味だと思います．_

### 2006-06-23

技術情報

暇をみて，日本語訳していたものをリリースします．

- Vectrex HP3000 Programming Notes

日本語訳

もし，描画の前にベクトルの位置を変えるだけであれば，ステップ5，6は省略できます．

さて，ややこしいところが，やってきました．どうやって，X方向の速度，Y方向の速度，X,Y座標積分器オフセットを計算するのか．また，RAMPパルスをどのぐらい長く生成するのでしょうか．

画面が静止しているように見えるためには，RAMPパルスの長さが重要になります．RAMPがアクティブ時に割り込みが発生すると，RAMPパルス長が変わってしまうので，ベクトル描画サイクル中は，割り込みを禁止しなければなりません（MUST）．

私の知る限り，このシステムを動作させるには，3通りの方法がありえます．すべての方法で，X,Y積分器オフセットは定数で，ズームイン／アウトに利用できることが，仮定されています．

(1) （私見では）EXEC ROMに最も近い方法です．まず，すべてのベクトルについて，RAMPパルスの固定長を持ちます．8ビットDAC値で指定するため，X座標，Y座標の両方とも，255単位のベクトルの解像度を持つことなります．これは，画面の解像度が，256x256という意味ではありません．RAMP時間とX,Y積分器オフセットの値により，255単位のベクトルは，非常に小さくなったり，非常に大きくなったりします．これは，すべては，最後の積分器の位置に対し，相対的に行なわれるためです（訳注：RAMP時間はベクトル長の拡大・縮小，X,Y積分器オフセットは平行移動の効果もつので，ベクトル描画ごとに，255単位の大きさが変わるという意味です）．私は，この方法が，計算が最もすくないと見積もっています．RAMPを固定し，X,Y積分器オフセットにより，単位長を設定できます．

(2) まず，移動したい方向に応じたX,Y方向の値をルックアップ表（計算によって求めることも可）として持ちます．これらの値は，ひとつの固定ベクトル単位長で，規定されています．必要なベクトル長を生成するためには，RAMP長か，X,Y積分器オフセットを変更することを選択できます．ちょうど，X,Y積分器に設定した値と，固定単位長を掛け算することで，必要なベクトル長を得ることができます．

(3) 最も複雑な方法．すべての変数を変更します．しかし，これをどう計算するかは，神のみぞ知ることです．4変数もあるのですからね．

方法(1)，(2)は，計算すべき変数の数が限られているので，最も見込みがあります．RAMPとして固定値を使うことが，最も簡単な方法です．これは，要求されているRAMP設定するのに必要なCPUサイクルを数えるという問題を避けられるためです．RAMP時間の決定は，きちんと制御する必要があります．これは，不恰好な方法だが，特にハードウェアタイマがない場合でも，ソフトウェアで実現できないことはありません．

（訳注：以下，仕様的に重要でないので，訳していません）

### 2006-06-24

技術情報

重要なところを訳し忘れてました．

- Vectrex HP3000 Programming Notes

日本語訳

システムメモリマップ

チップ/お金/スペースを節約するため，光速船のメモリは，少し難解だが，2つのチップしか使っていありません．1つは，4つの2入力NANDゲートを含み，もう1つは，4つの2入力ORゲートを含んでいます．これは，利用しているゲート数を考慮すると，尊敬に値する仕事です．

|アドレス|用途|説明|
|------|----|-----|
|0000-7FFF|カートリッジROM領域|CART線は，~Eによってゲートされます．~Eは，ROMを有効にする出力に，直接与えられる信号を生成します（訳注：CART線，~Eの説明は，どこにもないので，詳細不明です）．このアドレス領域は，R/W線でゲートされず，直接カートリッジコネクタに与えられます（R/W）|
|8000-C7FF|未使用領域||
|C800-CFFF|光速船RAM領域 |1Kバイト x 2，ミラーリング2回（R/W）|
|D000-D7FF|6522PIAレジスタ|16バイト x 128，ミラーリング128回（R/W）|
|D800-DFFF|使用禁止|この領域は，6522とRAMが読み書きします|
|E000-FFFF|システムROM領域 |8Kバイト x 1（R/W）|

### 2006-06-25

スクリーンショット（左から，No.12，13）

<img src="https://github.com/jay-kumogata/InfoVectrex/blob/master/screenshots/kousokusen_060625_1.PNG" width="338px"/>
<img src="https://github.com/jay-kumogata/InfoVectrex/blob/master/screenshots/kousokusen_060625_2.PNG" width="338px"/>

画面描画ルーチンを書き直しました．1画面分のラインを配列で持ち，画面アップデート時に，その配列を元に，ラインを描画するように変更しました．また，画面アップデートも，裏画面を持つようにしたので，ちらつかなくなりました．太いラインを使うと，遅いので，細いラインに変更しました．

進捗状況

|日付|概要|詳細|
|----|----|----|
|2006/6/25|* Win32: ベクトル描画処理（DrawLine）を修正<br>* Win32: ベクトル描画処理（UpdateScreen）を修正||

しかし，ラインが細すぎるのと，速すぎて，弾が見えないので，ゲームとしては，いまいちです．来週は，もう少しチューニングをして，そろそろリリースしようかな．

### 2006-07-02

スクリーンショット（左から，No.14，15）

![](https://github.com/jay-kumogata/InfoVectrex/blob/master/screenshots/kousokusen_060701_0.PNG)
![](https://github.com/jay-kumogata/InfoVectrex/blob/master/screenshots/kousokusen_060701_1.PNG)

線の太さをキー操作で選択できるようしました．ゲームの時は，線を太くすると遅くして，タイトルの時は，線を細くして速くするなどができるようになりました．BIOSゲーム（MINE STORM）で，遊べるようになりました．

進捗状況

|日付|概要|詳細|
|----|----|----|
|2006/7/1|* Win32: ペン選択ボタン（0，1，2）処理を追加||

公開して欲しいという声も大きくなってきた（どこで？）ので，公開しようかなと思っています．公開すると，しばらくいじらないので，飽きたら，公開しようかな．

### 2006-07-08

進捗状況

|日付|概要|詳細|
|----|----|----|
|2006/7/8|* v0.3Jリリース(06/07/08)|プロジェクト開始から１年経つのにリリースファイルがないのも残念なので，まだまだ不十分な箇所もありますが，リリースしました．6809エミュレータも含んでいるので，再利用できるものも多いかもしれないです．|

スクリーンショット（再掲）

![](https://github.com/jay-kumogata/InfoVectrex/blob/master/screenshots/kousokusen_060701_0.PNG)
![](https://github.com/jay-kumogata/InfoVectrex/blob/master/screenshots/kousokusen_060701_1.PNG)

参考文献

- [* Vecx emulator](http://www.valavan.net/vectrex.html)
- [* All about 光速船](http://vectrex.takuranke.com/)                                                                                                                             

### 2006-07-17

スクリーンショット（左から，No.16，17）

![](https://github.com/jay-kumogata/InfoVectrex/blob/master/screenshots/kousokusen_060717_1.PNG)
![](https://github.com/jay-kumogata/InfoVectrex/blob/master/screenshots/kousokusen_060717_2.PNG)

_(2021-11-03) スクリーンショットNo.17は，散逸してしまいました．_

|日付|概要|詳細|
|----|----|----|
|2006/7/16|* 6809: MUL命令修正（Cフラグ動作：Bレジスタの7ビット目と連動）||
|2006/7/17|* Win32: デバッグメッセージ出力を修正<br>* 6809: MINE STORM用暫定パッチ（画面崩れ対策）||

v0.3Jをリリースした後に，MINE STOMEのSTAGE #2で，四角い敵を倒すと，画面が崩れるバグを発見しました．直接の原因は，下のコードで，$E59Cで，Aに4以上の値が入ってくるために，Xに変な値が入るためらしいです．

	E599	8EE25A	LDX	#$E25A
	E59C	A641	LDA	1,U
	E59E	48	ASLA
	E59F	AE86	LDX	A,X

ただ，なぜここに，その値が書き込まれるのかは，判明できなかったので，パッチを当てることで，問題は回避できました．よく，nesterJとかで，そういうのがありました．

### 2006-07-28

_(2021-11-03) 最後のまとめ資料です．開発としては，ほぼ終了していきます．_

ベクタースキャン方式のゲーム機エミュレータについて

はじめに

ベクタースキャン方式のゲーム機として，光速船のエミュレータを開発しました．いままでのファミコンとか，ゲームボーイのようなラスタースキャン方式のゲーム機と違うこともありましたので，簡単にまとめておきます．

グラフィックスのエミュレーション

最大にして，唯一といってよいのが，グラフィックスのエミュレーションです．

(a) ラスタースキャン方式の場合

ラスタースキャン方式の場合には，以下のようなグラフィックス処理を実行します．

	for ( 走査線数だけ繰り返し ) {
	　走査線1本に対応するCPUクロック分だけ，CPUエミュレーション実行
	　走査線1本だけ，フレームバッファに描画
	}
	フレームバッファを画面へ転送

(b) ベクタースキャン方式の場合

これに対して，ベクタースキャン方式の場合には，以下のようなグラフィックス処理を実行することにしました．

	for ( 1/10秒程度に対応するCPUクロック分だけ繰り返し ) {
	　CPU1命令を実行（CPUクロック数を保存）
	　CPUクロック数分だけ，周辺装置（6522A VIA）の処理を実行
	　if ( ビームがONか？ ) {
	　　ビーム始点，ビーム輝度を保存
	　　CPUクロック数分だけ，ビーム移動
	　　ビーム終点を保存
	　}
	}
	フレームバッファをクリア
	保存されたビームの始点，終点，輝度に基づいて，フレームバッファにライン描画
	フレームバッファを画面へ転送

正解というわけではないと思いますが，InfoVectrexでは，問題なく動作しています．他のエミュレータの構成法について情報があれば，教えて下さい．

おわりに

この文書では，ベクタースキャンのエミュレータの構成法について，InfoVectrexで採用した方法を紹介しました．

参考文献

- [コンソールエミュレータについて](https://github.com/jay-kumogata/InfoNES/tree/master/doc/011021_ConsoleEmulator)（エミュレータ構成法について解説がある）
- [光速船・Vectrexに関するコラム](http://vectrex.takuranke.com/vectrex_column.html)（ベクタースキャン方式について解説がある）

### 2006-08-15

なぜ，エミュレータ作者は，開発休止を宣言するのか？

謝辞

エミュレータを作れて，本当に幸せだったなと思います．いろいろなものに挑戦したけど，エミュレータ作りは，最も成功したもののひとつでした．成功したものといっていいと思います．

1999年夏，ゆとりのある時間が流れていました．当時，MAMEはもう存在しており，「飛翔鮫」が動くのを見て，驚嘆したことを覚えています．そして，自分でも，ファミコンエミュレータを作ってみることにしました．ベースは，pnesxで，サウンド，マッパ等のサポートを繰り返したものが，InfoNESです．InfoNESは，多くのプラットフォームに移植されました．特に，組み込み系では，強かったです．

ただ，今日に至るまで，nester系には，完敗です．Darren Ranalli氏には，一度お会いしたいと思っています．

いろいろなターゲットにも挑戦してみました．ゲームボーイのInfoGB，スーファミのInfoSNES，ぴゅう太のInfoPyuutaは，移植に近いです．CHIP-8のInfoChip8，光速船のInfoVectrexは，CPUから開発しました．いまの時代に，CPUからエミュレータを作る人は，ほとんどいないと思います．

「そろそろ，潮時だろう．」

InfoVectrexを公開した時に，天からお告げがあったような気がしました．InfoVectrexをもって，しばらく，エミュレータ開発は，お休みしようと思います．あれから，ちょうど7年．エミュレータ開発を通じて，技術的にも，いろいろ勉強したし，いろいろな人と出会えた．特に，移植者の方，エミュレータサイトの方，雑誌関連の方には，この場をかりて感謝したいです．ありがとうございました．

最後に，エミュレータ作者が，よく休止宣言するのをみて，不思議に眺めていた．でも，いまは，その気持ちがなんとなく分かる気がする．

参考資料

- (1) [InfoNES（ファミコン）](https://github.com/jay-kumogata/InfoNES)
- (2) [InfoGB（ゲームボーイ）](https://github.com/jay-kumogata/InfoGB)
- (3) [InfoVectrex（光速船）](https://github.com/jay-kumogata/InfoVectrex)

![](https://github.com/jay-kumogata/InfoVectrex/blob/master/screenshots/kousokusen_060701_0.PNG)
![](https://github.com/jay-kumogata/InfoVectrex/blob/master/screenshots/kousokusen_060701_1.PNG)

- (4) InfoPyuta（ぴゅう太）
- (5) [InfoChip8（CHIP-8）](https://github.com/jay-kumogata/InfoChip8)
- (6) InfoSNES（スーパーファミコン）

_(2021-11-03) InfoPyutaとInfoSNESは，現在は公開中止です．いずれも商用ゲームは動作しません．_
_また，エミュレータ開発は中止と言いつつも，[PyChip8](https://github.com/jay-kumogata/PyChip8)と[MonadChip8](https://github.com/jay-kumogata/MonadChip8)を開発することになります．_

### 2021-10-28

15年前に執筆した光速船エミュレータ開発記を[GitHub](https://github.com/jay-kumogata/InfoVectrex/tree/master/doc/050605_DevNote/)の方に復刻しています．
「100日後に完成する光速船エミュレータ」のような仕上がりになりました（嘘です）．

以上